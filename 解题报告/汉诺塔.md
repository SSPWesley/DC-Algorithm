2021-8 CSG-TEST Online Judge 1036：汉诺塔 - 解题报告（钟承文）
# 内容 #
## 题目大意 ##
第一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。将其从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。现在给你一个n片圆盘的汉诺塔，并从小到大编号为1至n。请你输出搬动n个圆盘最少次数的全过程。
## 解题思路 ##
利用3个圆盘简单模拟其运动过程后可以得出：

1.当 n 等于 1 的时候，直接把圆盘从 A 移动到 C；

2.当 n > 1 的时候，可分为3步：

（1）把 A 柱子上面的 (n-1) 个盘子，从 A 移动到 B；

（2）把 A 柱子上面的第 n 个盘子由 A 移动到 C；

（3）把第一步 B 柱子上的 (n-1) 个盘子由 B 移动到 C。

3.最后在算法的实现中利用递归的思想即可模拟得出结论。
## 复杂度分析 ##
先取5个圆盘来分析时间复杂度，n=5时，总的执行步骤数为3+7x2^0+7x2^1+7x2^2+6x2^2；以此类推推广至n时，则为3+(2^0+2^1+…+2^(n-3))+6x2^2=2.5x2^n-4，故汉诺塔时间复杂度为O(2^n)。
## 算法资料 ##
递归算法。
## 心得体会 ##
用递归求解汉诺塔时，其复杂度是指数级的算法，n越大所得结果越大，所需时间越长。这种算法不适用计算过大的数据。
## 代码 ##
```C++
#include<iostream>
using namespace std;
//把上面n-1个搬到第二个柱子
// 把第n个搬到第三个柱子
//把n-1个搬到第三个柱子
void hanoi(int n, char a, char b, char c) {
	if (n == 0) {
		return ;
	}
	//将n-1个盘子由A经过C移动到B
	hanoi(n - 1, a, c, b);
	//将盘子从a移到c
	cout << "Move disk " << n << " from "<<a<<" to "<<c<< endl;
	//剩下的n-1盘子，由B经过A移动到C
	hanoi(n-1, b,a, c);
}
int main() {
	int n, step = 1;
	cin >> n;
	hanoi(n, 'A', 'B', 'C');
}
```

